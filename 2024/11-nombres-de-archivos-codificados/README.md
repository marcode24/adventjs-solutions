# Reto 11: Nombres-de-archivos-codificados

**El Grinch ha hackeado üè¥‚Äç‚ò†Ô∏è los sistemas del taller de Santa Claus** y ha codificado los nombres de todos los archivos importantes. Ahora los elfos no pueden encontrar los archivos originales y necesitan tu ayuda para descifrar los nombres.

Cada archivo sigue este formato:

- Comienza con un n√∫mero (puede contener cualquier cantidad de d√≠gitos).
- Luego tiene un guion bajo `_`.
- Contin√∫a con un **nombre de archivo y su extensi√≥n.**
- Finaliza con una extensi√≥n extra al final (que no necesitamos).

Ten en cuenta que el nombre de los archivos pueden contener letras (a-z, A-Z), n√∫meros (0-9), **otros guiones bajos** (_) y guiones (-).

Tu tarea es implementar una funci√≥n que reciba un string con el nombre de un archivo codificado y devuelva solo la parte importante: **el nombre del archivo y su extensi√≥n.**

Ejemplos:

```js
decodeFilename('2023122512345678_sleighDesign.png.grinchwa')
// ‚ûû "sleighDesign.png"

decodeFilename('42_chimney_dimensions.pdf.hack2023')
// ‚ûû "chimney_dimensions.pdf"

decodeFilename('987654321_elf-roster.csv.tempfile')
// ‚ûû "elf-roster.csv"
```

## Mi soluci√≥n explicada

```js
function decodeFilename(filename) {
  const underscoreIndex = filename.indexOf('_');
  const lastDotIndex = filename.lastIndexOf('.');
  return filename.slice(underscoreIndex + 1, lastDotIndex);
}
```

Para resolver este reto, de manera sencilla, he utilizado el m√©todo `slice()` para extraer la parte del string que necesitamos. ¬øComo es que funciona `slice()`? Lo que hace es devolver una copia de una parte del string, desde el √≠ndice inicial hasta el √≠ndice final (sin incluirlo). Ejemplo:

```js
const str = 'Hello, World!';
console.log(str.slice(7, 12)); // "World"
```

En este caso, `slice(7, 12)` extrae la parte del string desde el √≠ndice 7 hasta el √≠ndice 12 (sin incluirlo), devolviendo `"World"`.

Ahora, para resolver este reto, he utilizado `slice()` de la siguiente manera:

Primero, obtengo el √≠ndice del guion bajo `_` con el m√©todo `indexOf()`. ¬øPor qu√© el primer guion bajo? Porque el n√∫mero que est√° al principio del string es lo que no necesitamos.

Luego, obtengo el √≠ndice del √∫ltimo punto `.` con el m√©todo `lastIndexOf()`. ¬øPor qu√© el √∫ltimo punto? Porque el punto que est√° al final del string es lo que no necesitamos.

Finalmente, utilizo el m√©todo `slice()` para extraer la parte del string que necesitamos.

Veamos con un ejemplo:

Supongamos que tengo la siguiente cadena:

```js
const filename = '2023122512345678_sleighDesign.png.grinchwa';
```

Primero, obtengo el √≠ndice del primer guion bajo `_` con el m√©todo `indexOf()`:

```js
// const underscoreIndex = '2023122512345678_sleighDesign.png.grinchwa'.indexOf('_');
const underscoreIndex = filename.indexOf('_'); // 16
```

Luego, obtengo el √≠ndice del √∫ltimo punto `.` con el m√©todo `lastIndexOf()`:

```js
// const lastDotIndex = '2023122512345678_sleighDesign.png.grinchwa'.lastIndexOf('.');
const lastDotIndex = filename.lastIndexOf('.'); // 33
```

Finalmente, utilizo el m√©todo `slice()` para extraer la parte del string que necesitamos:

```js
// return '2023122512345678_sleighDesign.png.grinchwa'.slice(underscoreIndex + 1, lastDotIndex);
// return '2023122512345678_sleighDesign.png.grinchwa'.slice(16 + 1, 33);
// return '2023122512345678_sleighDesign.png.grinchwa'.slice(17, 33);
return filename.slice(underscoreIndex + 1, lastDotIndex); // "sleighDesign.png"
```

Y eso es todo lo que necesitamos para resolver este reto. üéâ

**Igual podemos hacerlo con expresiones regulares, pero esta soluci√≥n es m√°s sencilla y f√°cil de entender.**
